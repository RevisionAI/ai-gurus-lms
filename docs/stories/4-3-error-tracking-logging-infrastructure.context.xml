<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>4-3-error-tracking-logging-infrastructure</story-id>
    <story-title>Error Tracking &amp; Logging Infrastructure</story-title>
    <epic-id>epic-4</epic-id>
    <epic-title>Production Deployment &amp; Monitoring</epic-title>
    <generated-date>2025-11-27</generated-date>
    <project-root>/Users/eddyh/Documents/2025/Q3/Projects/Vibe Tribe/Vibe Tribe/AI GURUS v12claude/ai-gurus-lms</project-root>
  </metadata>

  <story-definition>
    <user-story>
      As a developer,
      I want comprehensive error tracking and logging with alerting,
      so that I can detect and diagnose production issues immediately.
    </user-story>

    <acceptance-criteria>
      <criterion id="AC1">Sentry integrated for error tracking (@sentry/nextjs installed)</criterion>
      <criterion id="AC2">All unhandled exceptions automatically captured and logged</criterion>
      <criterion id="AC3">Error context includes: User ID, request URL, stack trace, browser/OS info</criterion>
      <criterion id="AC4">Source maps configured (Sentry shows original TypeScript code)</criterion>
      <criterion id="AC5">Error severity classification implemented (P0: critical, P1: high, P2: medium, P3: low)</criterion>
      <criterion id="AC6">Automated alerting configured (P0 → immediate, P1 → 1 hour, P2/P3 → daily digest)</criterion>
      <criterion id="AC7">Structured logging implemented (Pino) for server-side logs</criterion>
      <criterion id="AC8">Log aggregation configured (Vercel Logs, searchable)</criterion>
      <criterion id="AC9">Log retention policy: 30 days for all logs, 90 days for error logs</criterion>
      <criterion id="AC10">Dashboard created: Error trends, most common errors, error rate over time</criterion>
      <criterion id="AC11">Documentation: Error tracking and logging guide</criterion>
    </acceptance-criteria>

    <priority>P0 - Critical for Production Launch</priority>
    <story-points>8</story-points>
    <dependencies>
      <dependency>Story 4.1: Production hosting must be deployed first</dependency>
      <dependency>Epic 1: Infrastructure foundation (database, rate limiting) already complete</dependency>
    </dependencies>
  </story-definition>

  <technical-specification>
    <architecture-context>
      <description>
        This story establishes production-grade observability infrastructure by integrating
        Sentry for error tracking with session replay, implementing Pino structured logging,
        and configuring automated alerting with severity-based routing. The implementation
        captures all unhandled exceptions, logs critical application events, and provides
        real-time visibility into production issues.
      </description>

      <integration-points>
        <integration>
          <name>Sentry Error Tracking</name>
          <type>External Service</type>
          <description>Captures client-side and server-side errors with full context and session replay</description>
          <files>
            <file>src/lib/sentry.ts (NEW)</file>
            <file>sentry.client.config.ts (AUTO-GENERATED by wizard)</file>
            <file>sentry.server.config.ts (AUTO-GENERATED by wizard)</file>
            <file>sentry.edge.config.ts (AUTO-GENERATED by wizard)</file>
          </files>
        </integration>

        <integration>
          <name>Pino Structured Logging</name>
          <type>Logging Library</type>
          <description>JSON structured logging with automatic PII redaction and Vercel aggregation</description>
          <files>
            <file>src/lib/logger.ts (NEW)</file>
          </files>
        </integration>

        <integration>
          <name>API Route Error Handling</name>
          <type>Code Pattern</type>
          <description>All existing API routes need Sentry error capture integration</description>
          <files>
            <file>src/app/api/**/*.ts (UPDATE existing error handlers)</file>
          </files>
        </integration>

        <integration>
          <name>Vercel Logs Aggregation</name>
          <type>Platform Service</type>
          <description>Automatic stdout/stderr capture with searchable dashboard</description>
          <configuration>Enabled automatically in Vercel Pro plan</configuration>
        </integration>
      </integration-points>

      <technology-stack>
        <package name="@sentry/nextjs" version="^8.x" purpose="Error tracking, session replay, performance monitoring"/>
        <package name="pino" version="latest" purpose="Structured JSON logging"/>
        <package name="pino-pretty" version="latest" purpose="Pretty-printing logs in development"/>
      </technology-stack>
    </architecture-context>

    <implementation-details>
      <task id="task-1">
        <title>Install and configure Sentry</title>
        <installation>
          <command>npx @sentry/wizard@latest -i nextjs</command>
          <description>
            Wizard automatically:
            - Installs @sentry/nextjs package
            - Creates sentry.client.config.ts, sentry.server.config.ts, sentry.edge.config.ts
            - Configures next.config.js for source maps upload
            - Prompts for DSN and auth token
          </description>
        </installation>

        <environment-variables>
          <variable>
            <name>NEXT_PUBLIC_SENTRY_DSN</name>
            <description>Public Sentry DSN (client-side error tracking)</description>
            <example>https://xxx@sentry.io/xxx</example>
            <required>true</required>
          </variable>
          <variable>
            <name>SENTRY_AUTH_TOKEN</name>
            <description>Sentry auth token for uploading source maps</description>
            <example>sntrys_xxx</example>
            <required>true</required>
          </variable>
          <variable>
            <name>SENTRY_ORG</name>
            <description>Sentry organization slug</description>
            <example>ai-gurus</example>
            <required>true</required>
          </variable>
          <variable>
            <name>SENTRY_PROJECT</name>
            <description>Sentry project slug</description>
            <example>ai-gurus-lms</example>
            <required>true</required>
          </variable>
        </environment-variables>

        <sentry-configuration>
          <file-path>src/lib/sentry.ts</file-path>
          <configuration-code><![CDATA[
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,

  // Performance monitoring: 10% of transactions in production
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,

  // Session replay for error debugging
  replaysOnErrorSampleRate: 1.0,  // 100% replay on errors
  replaysSessionSampleRate: 0.1,  // 10% general session replay

  // Filter sensitive data before sending to Sentry
  beforeSend(event) {
    // Remove passwords from request data
    if (event.request?.data?.password) {
      delete event.request.data.password;
    }

    // Redact authorization headers
    if (event.request?.headers?.authorization) {
      event.request.headers.authorization = '[REDACTED]';
    }

    // Redact authentication tokens
    if (event.request?.cookies) {
      const cookies = event.request.cookies;
      Object.keys(cookies).forEach(key => {
        if (key.includes('token') || key.includes('session')) {
          cookies[key] = '[REDACTED]';
        }
      });
    }

    return event;
  },

  // Ignore common non-actionable errors
  ignoreErrors: [
    'ResizeObserver loop limit exceeded',
    'ResizeObserver loop completed with undelivered notifications',
    'Network request failed',
    'Load failed',
    'Failed to fetch',
    'NetworkError when attempting to fetch resource',
    'Non-Error promise rejection captured',
  ],

  // Ignore specific URLs (third-party scripts, analytics)
  denyUrls: [
    /extensions\//i,
    /^chrome:\/\//i,
    /^chrome-extension:\/\//i,
  ],
});
]]></configuration-code>
        </sentry-configuration>

        <source-maps-configuration>
          <description>
            Next.js 15 automatically configures source maps upload via next.config.js when Sentry wizard runs.
            Verify configuration includes:
            - Source maps generated during build
            - Source maps uploaded to Sentry via Sentry Webpack Plugin
            - Source maps excluded from public deployment (not served to clients)
          </description>
          <verification>
            Trigger test error in production → Check Sentry dashboard → Verify TypeScript file names and line numbers visible (not compiled JS)
          </verification>
        </source-maps-configuration>
      </task>

      <task id="task-2">
        <title>Configure Sentry error capture and context</title>
        <description>
          Update error handling in existing API routes to capture exceptions with full context
        </description>

        <api-error-capture-pattern>
          <example-route>src/app/api/instructor/courses/route.ts</example-route>
          <code-pattern><![CDATA[
import * as Sentry from '@sentry/nextjs';
import { logger } from '@/lib/logger';

export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    // ... business logic

  } catch (error) {
    // Capture exception with Sentry (includes stack trace, context)
    Sentry.captureException(error, {
      tags: {
        route: '/api/instructor/courses',
        action: 'create_course',
        severity: 'P1',  // High priority: major feature broken
      },
      extra: {
        userId: session?.user?.id,
        requestBody: sanitizedBody,  // Never include passwords or tokens
        timestamp: new Date().toISOString(),
      },
      level: 'error',
    });

    // Also log to Pino for Vercel Logs aggregation
    logger.error({
      error: error instanceof Error ? error.message : 'Unknown error',
      stack: error instanceof Error ? error.stack : undefined,
      userId: session?.user?.id,
      route: '/api/instructor/courses',
    }, 'Failed to create course');

    // Return user-friendly error response
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Something went wrong',
        }
      },
      { status: 500 }
    );
  }
}
]]></code-pattern>
        </api-error-capture-pattern>

        <session-replay-configuration>
          <description>
            Session replay captures user interactions (clicks, scrolls, navigation) leading to errors.
            Configured via replaysOnErrorSampleRate and replaysSessionSampleRate in sentry.ts.
          </description>
          <privacy-settings>
            - Passwords: Automatically masked
            - Credit cards: Automatically masked
            - Custom sensitive inputs: Add data-sentry-mask attribute to mask
            - Text inputs: Not masked by default (can configure data-sentry-mask)
          </privacy-settings>
        </session-replay-configuration>

        <ignored-errors-rationale>
          <error pattern="ResizeObserver loop">Browser rendering quirk, not actionable</error>
          <error pattern="Network request failed">User connectivity issues, not application errors</error>
          <error pattern="Load failed">Resource loading failures (often browser extensions), not actionable</error>
        </ignored-errors-rationale>
      </task>

      <task id="task-3">
        <title>Implement error severity classification</title>
        <severity-definitions>
          <severity level="P0" label="Critical">
            <description>Site down, authentication failures, data loss risk, payment processing errors</description>
            <examples>
              - Database connection failure (site unusable)
              - Authentication system failure (users cannot login)
              - Data corruption detected (grades deleted, users missing)
              - Payment processing failures (revenue impact)
            </examples>
            <alerting>Immediate → Slack + Email + SMS (if configured)</alerting>
          </severity>

          <severity level="P1" label="High">
            <description>Major feature broken (course enrollment fails, assignment submission fails, grading unavailable)</description>
            <examples>
              - Course enrollment API returns 500 errors
              - Assignment submission fails (students cannot submit)
              - Gradebook API crashes (instructors cannot grade)
              - File uploads fail (R2 connection error)
            </examples>
            <alerting>Notification within 1 hour → Slack + Email</alerting>
          </severity>

          <severity level="P2" label="Medium">
            <description>Minor feature broken (search not working, notification delay, UI glitch)</description>
            <examples>
              - Course search returns empty results
              - Email notifications delayed or not sent
              - UI rendering issues (layout breaks, missing styles)
              - Non-critical API endpoints failing
            </examples>
            <alerting>Daily digest → Email only</alerting>
          </severity>

          <severity level="P3" label="Low">
            <description>Cosmetic issues, non-critical warnings, performance degradation (not blocking)</description>
            <examples>
              - Slow API response times (but not failing)
              - CSS styling inconsistencies
              - Non-critical console warnings
              - Minor accessibility issues
            </examples>
            <alerting>Daily digest → Email only</alerting>
          </severity>
        </severity-definitions>

        <tagging-strategy>
          <description>
            Add severity tags to Sentry.captureException() calls based on error impact.
            Severity classification allows filtering and alert routing in Sentry dashboard.
          </description>
          <implementation>
            Use tags.severity field: 'P0', 'P1', 'P2', or 'P3'
            Configure Sentry alert rules to match severity tags for routing
          </implementation>
        </tagging-strategy>
      </task>

      <task id="task-4">
        <title>Configure automated alerting</title>
        <alert-rules>
          <rule name="P0 Critical Errors">
            <trigger>Any error with tag severity:P0</trigger>
            <channels>Slack (#alerts channel) + Email (team@aigurus.com)</channels>
            <frequency>Immediate (no throttling)</frequency>
            <configuration>
              Sentry Project Settings → Alerts → New Alert Rule
              - Condition: Event tag severity equals P0
              - Action: Send notification to Slack + Email
              - Frequency: Every occurrence (no throttling)
            </configuration>
          </rule>

          <rule name="P1 High Priority Errors">
            <trigger>Any error with tag severity:P1</trigger>
            <channels>Slack (#alerts channel) + Email (team@aigurus.com)</channels>
            <frequency>1-hour digest (throttled to prevent spam)</frequency>
            <configuration>
              Sentry Project Settings → Alerts → New Alert Rule
              - Condition: Event tag severity equals P1
              - Action: Send notification to Slack + Email
              - Frequency: At most once per hour
            </configuration>
          </rule>

          <rule name="P2/P3 Low Priority Errors">
            <trigger>Any error with tag severity:P2 OR severity:P3</trigger>
            <channels>Email only (team@aigurus.com)</channels>
            <frequency>Daily digest (9 AM UTC)</frequency>
            <configuration>
              Sentry Project Settings → Alerts → New Alert Rule
              - Condition: Event tag severity equals P2 OR severity equals P3
              - Action: Send daily digest email
              - Frequency: Once per day at 9:00 AM UTC
            </configuration>
          </rule>

          <rule name="Error Spike Detection">
            <trigger>Error rate exceeds 10x normal baseline</trigger>
            <channels>Slack (#alerts channel) + Email (team@aigurus.com)</channels>
            <frequency>Immediate</frequency>
            <configuration>
              Sentry Project Settings → Alerts → New Alert Rule
              - Condition: Error rate increases by 10x compared to baseline
              - Action: Send notification to Slack + Email
              - Frequency: Immediate
            </configuration>
          </rule>
        </alert-rules>

        <slack-webhook-integration>
          <description>Configure Slack webhook for error notifications</description>
          <setup-steps>
            1. In Slack: Create #alerts channel (or use existing)
            2. In Slack: Apps → Incoming Webhooks → Add to Workspace → Select #alerts
            3. Copy webhook URL: https://hooks.slack.com/services/xxx/yyy/zzz
            4. In Sentry: Project Settings → Integrations → Slack → Add Webhook
            5. Paste webhook URL and select notification preferences
          </setup-steps>
        </slack-webhook-integration>

        <email-notification-configuration>
          <recipients>
            <recipient>dev@aigurus.com</recipient>
            <recipient>ops@aigurus.com</recipient>
          </recipients>
          <configuration>
            Sentry Project Settings → Notifications → Email
            - Add recipient emails
            - Configure per-severity preferences (P0 immediate, P1 hourly, P2/P3 daily)
          </configuration>
        </email-notification-configuration>
      </task>

      <task id="task-5">
        <title>Implement Pino structured logging</title>
        <logger-configuration>
          <file-path>src/lib/logger.ts</file-path>
          <configuration-code><![CDATA[
import pino from 'pino';

const logger = pino({
  // Log level: debug in development, info in production
  level: process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug'),

  // Format log level as uppercase string
  formatters: {
    level: (label) => {
      return { level: label.toUpperCase() };
    },
  },

  // ISO 8601 timestamps
  timestamp: pino.stdTimeFunctions.isoTime,

  // Base context included in all logs
  base: {
    env: process.env.NODE_ENV,
    service: 'ai-gurus-lms',
  },

  // Redact sensitive fields (never log passwords, tokens, PII)
  redact: {
    paths: [
      'password',
      'token',
      'apiKey',
      'authorization',
      'cookie',
      'session',
      'req.headers.authorization',
      'req.headers.cookie',
    ],
    censor: '[REDACTED]',
  },

  // Pretty-print in development (human-readable), JSON in production (machine-parseable)
  ...(process.env.NODE_ENV === 'development' && {
    transport: {
      target: 'pino-pretty',
      options: {
        colorize: true,
        translateTime: 'HH:MM:ss Z',
        ignore: 'pid,hostname',
      },
    },
  }),
});

export default logger;
]]></configuration-code>
        </logger-configuration>

        <log-levels>
          <level name="error">
            <use-case>Errors requiring attention (logged to Sentry automatically)</use-case>
            <example>logger.error({ error, userId }, 'Failed to create course')</example>
          </level>
          <level name="warn">
            <use-case>Warnings (rate limit hits, validation failures, deprecations)</use-case>
            <example>logger.warn({ ipAddress, attempts: 5 }, 'Multiple failed login attempts')</example>
          </level>
          <level name="info">
            <use-case>Important events (user registration, enrollment, submission, grading)</use-case>
            <example>logger.info({ userId, courseId }, 'User enrolled in course')</example>
          </level>
          <level name="debug">
            <use-case>Detailed debugging info (development only, disabled in production)</use-case>
            <example>logger.debug({ query, results }, 'Database query executed')</example>
          </level>
        </log-levels>

        <logging-best-practices>
          <practice>Always include context (userId, courseId, assignmentId) for correlation</practice>
          <practice>Never log passwords, tokens, session IDs, or raw PII (use redaction)</practice>
          <practice>Log at appropriate levels (error for failures, info for important events, debug for details)</practice>
          <practice>Include timestamps (automatic via Pino configuration)</practice>
          <practice>Use structured fields (not string concatenation) for searchability</practice>
        </logging-best-practices>

        <existing-console-log-replacement>
          <description>
            Replace console.log() calls in critical API routes with logger calls.
            Priority: API routes in /api/instructor/, /api/admin/, /api/student/
          </description>
          <example-replacement>
            <!-- Before -->
            console.log('User enrolled in course', userId, courseId);

            <!-- After -->
            logger.info({ userId, courseId }, 'User enrolled in course');
          </example-replacement>
        </existing-console-log-replacement>
      </task>

      <task id="task-6">
        <title>Configure Vercel Logs aggregation</title>
        <description>
          Vercel automatically captures all stdout/stderr output from Next.js application.
          Pino logs JSON to stdout, which Vercel aggregates and makes searchable.
        </description>

        <vercel-logs-access>
          <location>Vercel Dashboard → Project → Logs tab</location>
          <retention>
            - Hobby plan: 7 days
            - Pro plan: 3 months (recommended for production)
          </retention>
          <search-capabilities>
            - Full-text search across all log messages
            - Filter by log level (error, warn, info, debug)
            - Filter by time range (last hour, day, week, custom)
            - Filter by source (server, edge, build)
          </search-capabilities>
        </vercel-logs-access>

        <log-search-examples>
          <example>
            <query>level:ERROR userId:abc123</query>
            <description>Find all errors for specific user</description>
          </example>
          <example>
            <query>route:/api/instructor/courses action:create_course</query>
            <description>Find all course creation attempts</description>
          </example>
          <example>
            <query>level:WARN ratelimit</query>
            <description>Find all rate limit warnings</description>
          </example>
        </log-search-examples>

        <log-retention-policy>
          <all-logs>30 days (sufficient for troubleshooting, aligns with Vercel Pro 3-month retention)</all-logs>
          <error-logs>90 days (Sentry retains errors separately, searchable in Sentry dashboard)</error-logs>
          <export-capability>Vercel allows log export via API for long-term archival if needed</export-capability>
        </log-retention-policy>

        <log-access-procedures>
          <procedure name="Search logs for specific error">
            1. Navigate to Vercel Dashboard → Project → Logs
            2. Filter by level:ERROR
            3. Search for error message or requestId
            4. Click log entry to expand full context
            5. Copy requestId to correlate with Sentry error report
          </procedure>

          <procedure name="Export logs for analysis">
            1. Navigate to Vercel Dashboard → Project → Logs
            2. Apply filters (time range, level, search query)
            3. Click "Export" button (if available in Pro plan)
            4. Download JSON or CSV format
            5. Analyze in spreadsheet or log analysis tool
          </procedure>
        </log-access-procedures>
      </task>

      <task id="task-7">
        <title>Create monitoring dashboard</title>
        <sentry-dashboard-configuration>
          <description>Create custom dashboard in Sentry with widgets for error monitoring</description>

          <widget name="Error Trends">
            <type>Line chart</type>
            <metric>Error count over time</metric>
            <time-ranges>24 hours, 7 days, 30 days (switchable)</time-ranges>
            <configuration>
              Dashboard → Add Widget → Line Chart
              - Y-axis: count()
              - Group by: time (auto)
              - Time range: 24h / 7d / 30d tabs
            </configuration>
          </widget>

          <widget name="Most Common Errors">
            <type>Table</type>
            <metric>Top 10 errors by frequency (grouped by error message)</metric>
            <columns>Error message, Count, First seen, Last seen</columns>
            <configuration>
              Dashboard → Add Widget → Table
              - Columns: error.type, count(), min(timestamp), max(timestamp)
              - Sort by: count() descending
              - Limit: 10 rows
            </configuration>
          </widget>

          <widget name="Error Rate">
            <type>Big Number</type>
            <metric>Percentage of requests resulting in errors</metric>
            <calculation>(Error count / Total requests) * 100</calculation>
            <configuration>
              Dashboard → Add Widget → Big Number
              - Metric: (count(error) / count(transaction)) * 100
              - Format: Percentage
            </configuration>
          </widget>

          <widget name="Error Distribution by Endpoint">
            <type>Bar chart</type>
            <metric>Error count by API route (grouped by route tag)</metric>
            <configuration>
              Dashboard → Add Widget → Bar Chart
              - Y-axis: count()
              - Group by: tags.route
              - Sort by: count() descending
              - Limit: Top 10 routes
            </configuration>
          </widget>

          <widget name="Session Replay Links">
            <type>Issue list</type>
            <description>Quick access to session replays for recent errors</description>
            <configuration>
              Dashboard → Add Widget → Issue Stream
              - Filter: has:replay
              - Sort by: timestamp descending
              - Show: Issue title, timestamp, replay link
            </configuration>
          </widget>
        </sentry-dashboard-configuration>

        <dashboard-sharing>
          <description>Save dashboard as team default view</description>
          <steps>
            1. Complete dashboard configuration
            2. Click "Save Dashboard"
            3. Enable "Set as default dashboard for team"
            4. Share dashboard URL with team
          </steps>
        </dashboard-sharing>
      </task>

      <task id="task-8">
        <title>Create error tracking and logging documentation</title>
        <documentation-file>docs/error-tracking-logging.md</documentation-file>
        <required-sections>
          <section name="Overview">
            Summary of error tracking and logging infrastructure (Sentry + Pino + Vercel Logs)
          </section>

          <section name="Sentry Setup">
            - Installation steps (wizard command)
            - Environment variables configuration
            - Source maps verification
          </section>

          <section name="Error Severity Classification">
            - P0, P1, P2, P3 definitions with examples
            - When to use each severity level
            - How to tag errors with severity
          </section>

          <section name="Alert Channels and SLAs">
            - P0: Immediate → Slack + Email + SMS
            - P1: 1 hour → Slack + Email
            - P2/P3: Daily digest → Email
            - How to configure alert rules
          </section>

          <section name="Pino Logging Patterns">
            - How to import and use logger
            - Log levels (error, warn, info, debug)
            - What to log (events, context, errors)
            - What NOT to log (passwords, tokens, PII)
            - Example code patterns
          </section>

          <section name="Log Access Procedures">
            - Accessing Vercel Logs dashboard
            - Searching and filtering logs
            - Exporting logs for analysis
            - Correlating logs with Sentry errors (via requestId)
          </section>

          <section name="Troubleshooting Procedures">
            - Common error patterns and solutions
            - Debugging steps for production issues
            - How to use session replay for debugging
            - Escalation procedures for critical errors
          </section>

          <section name="Code Examples">
            - API route error capture example
            - Client-side error capture example
            - Structured logging example
            - Error severity tagging example
          </section>
        </required-sections>
      </task>

      <task id="task-9">
        <title>Integration testing and validation</title>
        <test-scenarios>
          <scenario name="API route unhandled exception">
            <trigger>Throw error in API route (e.g., throw new Error('Test error'))</trigger>
            <expected>Sentry captures error with stack trace, user context, request URL</expected>
            <verification>Check Sentry dashboard for error entry within 5 minutes</verification>
          </scenario>

          <scenario name="Client-side error">
            <trigger>Trigger error in browser (e.g., undefined.foo)</trigger>
            <expected>Sentry captures error with browser/OS info, user context, page URL</expected>
            <verification>Check Sentry dashboard for error entry with browser context</verification>
          </scenario>

          <scenario name="Source maps verification">
            <trigger>Trigger error in TypeScript file</trigger>
            <expected>Sentry shows original TypeScript file name and line number (not compiled JS)</expected>
            <verification>Stack trace in Sentry shows .tsx/.ts files, not .js files</verification>
          </scenario>

          <scenario name="Session replay capture">
            <trigger>Trigger error after user interactions (click, scroll, navigate)</trigger>
            <expected>Session replay captures all user actions leading to error</expected>
            <verification>Play session replay in Sentry to see user journey before error</verification>
          </scenario>

          <scenario name="Sensitive data filtering">
            <trigger>Trigger error with password in request body</trigger>
            <expected>Password redacted in Sentry error context</expected>
            <verification>Check Sentry error extra data for [REDACTED] instead of actual password</verification>
          </scenario>

          <scenario name="P0 immediate alert">
            <trigger>Trigger error with severity:P0 tag</trigger>
            <expected>Slack notification received immediately (within 1 minute)</expected>
            <verification>Check #alerts Slack channel for notification</verification>
          </scenario>

          <scenario name="P1 hourly digest">
            <trigger>Trigger multiple errors with severity:P1 tag within 1 hour</trigger>
            <expected>Email notification received within 1 hour with error digest</expected>
            <verification>Check email inbox for Sentry alert digest</verification>
          </scenario>

          <scenario name="Pino logs in Vercel">
            <trigger>Call logger.info() in API route</trigger>
            <expected>Log appears in Vercel Logs dashboard as JSON</expected>
            <verification>Search Vercel Logs for log message, verify JSON format</verification>
          </scenario>

          <scenario name="Dashboard metrics">
            <trigger>Generate multiple errors across different routes</trigger>
            <expected>Dashboard displays error trends, most common errors, distribution by endpoint</expected>
            <verification>Check Sentry dashboard for accurate metrics and charts</verification>
          </scenario>
        </test-scenarios>

        <testing-checklist>
          <item>Trigger test error in development, verify Sentry captures</item>
          <item>Trigger test error in production, verify source maps show TypeScript</item>
          <item>Verify session replay captures user interactions</item>
          <item>Verify sensitive data filtered (passwords, auth tokens)</item>
          <item>Trigger P0 error, verify immediate Slack notification</item>
          <item>Trigger P1 error, verify email notification within 1 hour</item>
          <item>Verify Pino logs searchable in Vercel Logs</item>
          <item>Verify dashboard shows accurate error metrics</item>
        </testing-checklist>
      </task>
    </implementation-details>
  </technical-specification>

  <existing-codebase-context>
    <current-error-handling>
      <description>
        API routes currently use console.error() for error logging with generic error responses.
        Error handling pattern is inconsistent across routes (some use console.error, some don't log at all).
        No centralized error tracking or alerting infrastructure exists.
      </description>

      <example-pattern file="src/app/api/instructor/courses/route.ts">
        <![CDATA[
catch (error) {
  console.error('Error creating course:', error);
  return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
}
]]>
      </example-pattern>

      <improvements-needed>
        - Replace console.error() with Sentry.captureException() + logger.error()
        - Add severity tags to errors (P0/P1/P2/P3)
        - Include user context (userId, requestBody) in error capture
        - Standardize error response format across all routes
      </improvements-needed>
    </current-error-handling>

    <api-routes-requiring-updates>
      <route-category name="Instructor API">
        <route>src/app/api/instructor/courses/route.ts</route>
        <route>src/app/api/instructor/courses/[id]/route.ts</route>
        <route>src/app/api/instructor/gradebook/[courseId]/route.ts</route>
        <route>src/app/api/instructor/gradebook/[courseId]/grade/route.ts</route>
        <route>src/app/api/instructor/assignments/[id]/route.ts</route>
        <route>src/app/api/instructor/templates/route.ts</route>
      </route-category>

      <route-category name="Student API">
        <route>src/app/api/student/enroll/route.ts</route>
        <route>src/app/api/student/assignments/[id]/submission/route.ts</route>
      </route-category>

      <route-category name="Admin API">
        <route>src/app/api/admin/users/route.ts</route>
        <route>src/app/api/admin/stats/route.ts</route>
      </route-category>
    </api-routes-requiring-updates>

    <middleware-context file="src/middleware.ts">
      <description>
        Middleware already implements rate limiting with Upstash.
        Currently uses console.warn() and console.error() for logging.
        Should be updated to use Pino logger for structured logging.
      </description>

      <logging-patterns>
        <!-- Current pattern -->
        console.warn(JSON.stringify({
          level: 'warn',
          message: 'Rate limit exceeded',
          ...
        }));

        <!-- Updated pattern with Pino -->
        logger.warn({
          type: 'rate_limit_exceeded',
          identifier: ip,
          endpoint: pathname,
          limit, remaining, resetAt
        }, 'Rate limit exceeded');
      </logging-patterns>
    </middleware-context>

    <health-check-endpoint file="src/app/api/health/db/route.ts">
      <description>
        Health check endpoint already implements error handling with descriptive messages.
        Should be updated to include Sentry error capture for database connection failures.
      </description>

      <current-error-handling>
        <![CDATA[
catch (error) {
  const errorMessage = error instanceof Error
    ? (error.message.includes('timeout') ? 'Connection timeout' : 'Database connection failed')
    : 'Database connection failed';

  return NextResponse.json({ status: 'unhealthy', error: errorMessage }, { status: 503 });
}
]]>
      </current-error-handling>

      <updated-error-handling>
        Add Sentry.captureException() with severity:P0 tag (database down is critical)
      </updated-error-handling>
    </health-check-endpoint>
  </existing-codebase-context>

  <definition-of-done>
    <criteria>
      <item>@sentry/nextjs package installed and wizard completed</item>
      <item>Sentry configuration files created (sentry.*.config.ts)</item>
      <item>Environment variables configured in Vercel (DSN, AUTH_TOKEN, ORG, PROJECT)</item>
      <item>src/lib/sentry.ts created with full configuration (beforeSend, ignoreErrors, session replay)</item>
      <item>Source maps upload configured and verified (TypeScript visible in Sentry)</item>
      <item>pino and pino-pretty packages installed</item>
      <item>src/lib/logger.ts created with Pino configuration (levels, redaction, formatting)</item>
      <item>Critical API routes updated to capture errors with Sentry + log with Pino</item>
      <item>Error severity tags (P0/P1/P2/P3) added to error capture calls</item>
      <item>Sentry alert rules configured (P0 immediate, P1 hourly, P2/P3 daily)</item>
      <item>Slack webhook integration configured for alerts</item>
      <item>Email notification recipients configured</item>
      <item>Sentry dashboard created with error trends, common errors, distribution widgets</item>
      <item>Vercel Logs verified as searchable and aggregating Pino logs</item>
      <item>docs/error-tracking-logging.md created with all required sections</item>
      <item>All test scenarios validated (API errors, client errors, source maps, session replay, alerts)</item>
      <item>Testing checklist completed (8 items verified)</item>
      <item>Story status updated to "ready-for-dev" → "in-progress" → "done"</item>
      <item>Sprint status YAML updated</item>
    </criteria>
  </definition-of-done>

  <related-documentation>
    <document path="docs/tech-spec-epic-4.md">
      <section>Error Tracking</section>
      <description>Epic-level technical specification for error tracking infrastructure</description>
    </document>

    <document path="docs/architecture.md">
      <section>Monitoring &amp; Observability</section>
      <description>Architecture decisions for Sentry, Pino, Vercel Logs, Better Stack</description>
    </document>

    <document path="docs/epics.md">
      <section>Story 4.3</section>
      <description>Epic breakdown with story dependencies and objectives</description>
    </document>
  </related-documentation>

  <dependencies-and-prerequisites>
    <prerequisite>
      <name>Story 4.1: Production Hosting Configuration</name>
      <status>Must be complete before starting Story 4.3</status>
      <reason>Sentry requires production deployment URL and Vercel project configuration</reason>
    </prerequisite>

    <prerequisite>
      <name>Vercel Project Created</name>
      <status>Must exist before configuring Sentry</status>
      <reason>Sentry environment variables configured in Vercel project settings</reason>
    </prerequisite>

    <prerequisite>
      <name>Sentry Account Created</name>
      <status>Must create account and project before wizard</status>
      <reason>Wizard requires Sentry DSN and auth token</reason>
    </prerequisite>

    <post-dependencies>
      <dependency>
        <name>Story 4.4: Performance Monitoring &amp; Uptime Tracking</name>
        <integration>Complements Sentry error tracking with uptime monitoring (Better Stack)</integration>
      </dependency>

      <dependency>
        <name>Story 4.5: Deployment Runbooks</name>
        <integration>Runbooks reference error tracking procedures and Sentry dashboard</integration>
      </dependency>
    </post-dependencies>
  </dependencies-and-prerequisites>

  <validation-criteria>
    <acceptance-test id="AC1">
      <criterion>Sentry integrated for error tracking (@sentry/nextjs installed)</criterion>
      <validation>
        - Run: npm list @sentry/nextjs
        - Verify: Package listed with version ^8.x
        - Verify: Files exist: sentry.client.config.ts, sentry.server.config.ts, sentry.edge.config.ts
      </validation>
    </acceptance-test>

    <acceptance-test id="AC2">
      <criterion>All unhandled exceptions automatically captured and logged</criterion>
      <validation>
        - Trigger: Throw error in API route: throw new Error('Test unhandled exception')
        - Expected: Error appears in Sentry dashboard within 5 minutes
        - Verify: Stack trace includes file name, line number, error message
      </validation>
    </acceptance-test>

    <acceptance-test id="AC3">
      <criterion>Error context includes: User ID, request URL, stack trace, browser/OS info</criterion>
      <validation>
        - Trigger: Authenticated API error with user session
        - Expected: Sentry error includes:
          * extra.userId (from session)
          * request.url (API endpoint)
          * exception.stacktrace (full trace)
          * contexts.browser (for client-side errors)
          * contexts.os (for client-side errors)
      </validation>
    </acceptance-test>

    <acceptance-test id="AC4">
      <criterion>Source maps configured (Sentry shows original TypeScript code)</criterion>
      <validation>
        - Trigger: Error in TypeScript file (e.g., src/app/api/instructor/courses/route.ts)
        - Expected: Sentry stack trace shows .ts file path, not .js
        - Verify: Line numbers match TypeScript source, not compiled JavaScript
      </validation>
    </acceptance-test>

    <acceptance-test id="AC5">
      <criterion>Error severity classification implemented (P0/P1/P2/P3)</criterion>
      <validation>
        - Check: Error capture calls include tags.severity field
        - Trigger: Errors at each severity level
        - Verify: Sentry errors tagged with P0, P1, P2, or P3
        - Verify: Dashboard allows filtering by severity tag
      </validation>
    </acceptance-test>

    <acceptance-test id="AC6">
      <criterion>Automated alerting configured (P0 → immediate, P1 → 1 hour, P2/P3 → daily digest)</criterion>
      <validation>
        - Trigger P0 error: Verify Slack notification within 1 minute
        - Trigger P1 error: Verify email notification within 1 hour
        - Trigger P2/P3 errors: Verify daily digest email at 9 AM UTC
        - Verify: Alert rules configured in Sentry Project Settings → Alerts
      </validation>
    </acceptance-test>

    <acceptance-test id="AC7">
      <criterion>Structured logging implemented (Pino) for server-side logs</criterion>
      <validation>
        - Check: src/lib/logger.ts file exists with Pino configuration
        - Check: API routes import and use logger (not console.log)
        - Trigger: logger.info() call in API route
        - Verify: Log appears in Vercel Logs as JSON with timestamp, level, context
      </validation>
    </acceptance-test>

    <acceptance-test id="AC8">
      <criterion>Log aggregation configured (Vercel Logs, searchable)</criterion>
      <validation>
        - Access: Vercel Dashboard → Project → Logs
        - Verify: Logs from Pino appear in dashboard
        - Verify: Search functionality works (search for specific log message)
        - Verify: Filter by level (ERROR, WARN, INFO, DEBUG)
      </validation>
    </acceptance-test>

    <acceptance-test id="AC9">
      <criterion>Log retention policy: 30 days for all logs, 90 days for error logs</criterion>
      <validation>
        - Check: Vercel Pro plan configured (3 months retention)
        - Check: Sentry project settings show 90-day retention for errors
        - Document: Log retention policy in docs/error-tracking-logging.md
      </validation>
    </acceptance-test>

    <acceptance-test id="AC10">
      <criterion>Dashboard created: Error trends, most common errors, error rate over time</criterion>
      <validation>
        - Access: Sentry Dashboard (saved as team default)
        - Verify: Widgets present:
          * Error Trends (line chart, 24h/7d/30d)
          * Most Common Errors (table, top 10)
          * Error Rate (percentage)
          * Error Distribution by Endpoint (bar chart)
          * Session Replay Links (issue list)
        - Verify: Dashboard displays accurate metrics after test errors
      </validation>
    </acceptance-test>

    <acceptance-test id="AC11">
      <criterion>Documentation: Error tracking and logging guide</criterion>
      <validation>
        - Check: docs/error-tracking-logging.md file exists
        - Verify: All required sections present (Overview, Sentry Setup, Severity Classification, etc.)
        - Verify: Code examples included (error capture, logging patterns)
        - Verify: Troubleshooting procedures documented
      </validation>
    </acceptance-test>
  </validation-criteria>

  <notes>
    <note type="implementation-priority">
      Focus on critical API routes first (instructor gradebook, admin user management, student enrollment).
      Can defer updating less critical routes (announcements, discussions) to future iterations.
    </note>

    <note type="cost-consideration">
      Sentry free tier (5,000 errors/month) sufficient for beta launch.
      Monitor quota usage in Sentry dashboard. Upgrade to Team plan ($29/month) if approaching limit.
    </note>

    <note type="privacy-compliance">
      Sentry's beforeSend hook filters sensitive data (passwords, tokens) before transmission.
      Session replay automatically masks password inputs. Review privacy policy for GDPR/CCPA compliance.
    </note>

    <note type="performance-impact">
      Sentry session replay adds ~30KB to client bundle. Performance monitoring samples 10% of transactions.
      Minimal performance impact expected. Monitor Core Web Vitals in Story 4.4.
    </note>

    <note type="integration-with-story-4-4">
      Story 4.4 adds Better Stack for uptime monitoring. Sentry focuses on error tracking, Better Stack on availability.
      Together they provide complete observability (errors + uptime + performance).
    </note>
  </notes>
</story-context>
